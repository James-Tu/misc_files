#include <linux/kernel.h>#include <linux/errno.h>#include <linux/init.h>#include <linux/module.h>#include <linux/uaccess.h>#include <linux/usb.h>#include <linux/slab.h>#include <linux/mutex.h>#include <linux/fs.h>#include <linux/miscdevice.h>/* Define these values to match your devices */#define USB_LEDS_VENDOR_ID	0x0109#define USB_LEDS_PRODUCT_ID	0x0621#define LEDS_DEBUG#ifdef LEDS_DEBUG  #define USB_LEDS_DBG(_fmt, _args...) printk(_fmt, ##_args)#else  #define USB_LEDS_DBG(_fmt, _args...)#endif/* table of devices that work with this driver */static struct usb_device_id leds_table[] = {	{ USB_DEVICE(USB_LEDS_VENDOR_ID, USB_LEDS_PRODUCT_ID) },	{ }					/* Terminating entry */};MODULE_DEVICE_TABLE(usb, leds_table);/* Structure to hold all of our device specific stuff */struct usb_leds {	struct usb_device	*udev;			/* the usb device for this device */	struct usb_interface	*intf;		/* the interface for this device */	struct usb_endpoint_descriptor *inep;	struct usb_endpoint_descriptor *outep;};struct usb_leds *this_usb_leds = NULL;static int leds_open(struct inode *inode, struct file *file){	USB_LEDS_DBG("----  leds_open  ----\n");	return 0;}static int leds_release(struct inode *inode, struct file *file){	USB_LEDS_DBG("----  leds_release  ----\n");	return 0;}static ssize_t leds_read(struct file *file, char *buffer, size_t count,			 loff_t *ppos){	struct usb_leds *leds = this_usb_leds;	unsigned char v = 0;	unsigned int pipe = usb_rcvbulkpipe(leds->udev, leds->inep->bEndpointAddress);	int actual_length;	#if 0int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,                 void *data, int len, int *actual_length,                 int timeout);#endif	// TODO pipe ??	usb_bulk_msg(leds->udev, pipe, &v, 1, &actual_length, 10 * HZ);	USB_LEDS_DBG("leds_read: v = %x\n", v);	USB_LEDS_DBG("actual_length = %d\n", actual_length);	put_user(v, buffer);		return 1;}static ssize_t leds_write(struct file *file, const char *user_buffer,			  size_t count, loff_t *ppos){	struct usb_leds *leds = this_usb_leds;	unsigned char v = 0;	unsigned int pipe = usb_sndbulkpipe(leds->udev, leds->outep->bEndpointAddress);	int actual_length;	get_user(v, user_buffer);	USB_LEDS_DBG("leds_write: v = %x\n", v);	#if 0int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,                 void *data, int len, int *actual_length,                 int timeout);#endif	// TODO pipe ??	usb_bulk_msg(leds->udev, pipe, &v, 1, &actual_length, 10 * HZ);	USB_LEDS_DBG("actual_length = %d\n", actual_length);		return 1;}static const struct file_operations leds_fops = {	.owner =	THIS_MODULE,	.read =		leds_read,	.write =	leds_write,	.open =		leds_open,	.release =	leds_release,};struct miscdevice usb_leds_misc = {	.minor = MISC_DYNAMIC_MINOR,	.name = "usb_leds",	.fops = &leds_fops,};static int leds_probe(struct usb_interface *intf,		      const struct usb_device_id *id){	struct usb_device *dev = interface_to_usbdev(intf);	struct usb_leds *leds;	struct usb_endpoint_descriptor *inep = NULL, *outep = NULL, *tempep;	int ret = 0;	USB_LEDS_DBG("----  leds_probe  ----\n");		leds = kzalloc(sizeof(struct usb_leds), GFP_KERNEL);	if(NULL == leds)	{		printk("alloc mem error.\n");		return -ENOMEM;	}	leds->udev = dev;	leds->intf = intf;	tempep = &intf->cur_altsetting->endpoint[0].desc;	if(usb_endpoint_is_bulk_in(tempep))		inep = tempep;	else		outep = tempep;	tempep = &intf->cur_altsetting->endpoint[1].desc;	if(usb_endpoint_is_bulk_in(tempep))		inep = tempep;	else		outep = tempep;	USB_LEDS_DBG("inep->bEndpointAddress = 0x%x\n", inep->bEndpointAddress);	USB_LEDS_DBG("outep->bEndpointAddress = 0x%x\n", outep->bEndpointAddress);	leds->inep = inep;	leds->outep = outep;		ret = misc_register(&usb_leds_misc);	if(ret < 0)	{		printk("misc_register error. \n");		goto err_misc_register;	}	usb_set_intfdata(intf, leds);	this_usb_leds = leds;	return 0;	err_misc_register:	kfree(leds);	return ret;}static void leds_disconnect(struct usb_interface *intf){	struct usb_leds *leds = usb_get_intfdata (intf);	USB_LEDS_DBG("----  leds_disconnect  ----\n");	usb_set_intfdata(intf, NULL);	if (leds) 	{		misc_deregister(&usb_leds_misc);		kfree(leds);		this_usb_leds = NULL;	}}static struct usb_driver leds_driver = {	.name =		"usb_leds",	.probe =	leds_probe,	.disconnect	= leds_disconnect,	.id_table =	leds_table,};static int __init usb_leds_init(void){	int result;	USB_LEDS_DBG("----  usb_leds_init  ----\n");	/* register this driver with the USB subsystem */	result = usb_register(&leds_driver);	if (result)		err("usb_register failed. Error number %d", result);	return result;}static void __exit usb_leds_exit(void){	USB_LEDS_DBG("----  usb_leds_exit  ----\n");		/* deregister this driver with the USB subsystem */	usb_deregister(&leds_driver);}module_init(usb_leds_init);module_exit(usb_leds_exit);MODULE_LICENSE("GPL");